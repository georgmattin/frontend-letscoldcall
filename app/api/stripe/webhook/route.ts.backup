import { NextRequest, NextResponse } from 'next/server'
import { headers } from 'next/headers'
import Stripe from 'stripe'
import { createClient } from '@supabase/supabase-js'
import { sendOrderEmails } from '@/lib/email-utils'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
})

const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!

export async function POST(request: NextRequest) {
  const body = await request.text()
  const headersList = await headers()
  const sig = headersList.get('stripe-signature')

  let event: Stripe.Event

  try {
    event = stripe.webhooks.constructEvent(body, sig!, endpointSecret)
  } catch (err: any) {
    console.error(`Webhook signature verification failed.`, err.message)
    return new NextResponse(`Webhook Error: ${err.message}`, { status: 400 })
  }

  // Use service role key to bypass RLS
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )

  console.log(`üîî Stripe webhook received: ${event.type}`, event.id)

  // Handle the event
  switch (event.type) {
    case 'customer.created':
      const customer = event.data.object as Stripe.Customer
      console.log('Customer created:', customer.id, customer.email)
      
      // Note: We'll update with customer_id when we process checkout session
      break

    case 'customer.subscription.created':
      const subscription = event.data.object as Stripe.Subscription
      console.log('Subscription created:', subscription.id, 'for customer:', subscription.customer)
      
      // Note: We'll update with subscription_id when we process checkout session
      break

    case 'checkout.session.completed':
      const session = event.data.object as Stripe.Checkout.Session

      console.log('üí≥ Payment successful:', session.id)
      console.log('üìã Session metadata:', session.metadata)
      console.log('üë§ Customer ID:', session.customer)
      console.log('üìÑ Subscription ID:', session.subscription)

      try {
        // Get the metadata from the session
        const {
          user_id,
          package_id,
          phone_number_selection_id,
          phone_number
        } = session.metadata!

        // Update phone number selection with Stripe IDs
        const updateData: any = {
          status: 'paid',
          stripe_session_id: session.id,
          updated_at: new Date().toISOString()
        }

        // Add customer ID if available
        if (session.customer) {
          updateData.stripe_customer_id = typeof session.customer === 'string' 
            ? session.customer 
            : session.customer.id
        }

        // Add subscription ID if available
        if (session.subscription) {
          updateData.stripe_subscription_id = typeof session.subscription === 'string'
            ? session.subscription
            : session.subscription.id
        }

        console.log('üîÑ Updating phone_number_selections with:', updateData)
        console.log('üéØ For selection ID:', phone_number_selection_id)

        // First, check if the record exists
        const { data: existingRecord, error: findError } = await supabase
          .from('phone_number_selections')
          .select('*')
          .eq('id', phone_number_selection_id)
          .single()

        if (findError || !existingRecord) {
          console.error('‚ùå Record not found:', findError, phone_number_selection_id)
        } else {
          console.log('üìã Found existing record:', existingRecord)
        }

        const { data, error } = await supabase
          .from('phone_number_selections')
          .update(updateData)
          .eq('id', phone_number_selection_id)
          .select()

        if (error) {
          console.error('‚ùå Error updating phone_number_selections:', error)
        } else {
          console.log('‚úÖ Successfully updated phone_number_selections:', data)
          console.log('üìä Updated rows count:', data.length)
        }

        // Use local URL for internal calls (webhook calling same server)
        const baseUrl = 'http://localhost:3001' // Direct local call
        
        // Trigger the actual phone number purchase
        console.log('üöÄ Calling purchase endpoint from webhook...')
        console.log('üîó Using URL:', `${baseUrl}/api/rent-number/purchase`)
        const purchaseResponse = await fetch(`${baseUrl}/api/rent-number/purchase`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer webhook-${process.env.STRIPE_WEBHOOK_SECRET}`, // Webhook authorization
          },
          body: JSON.stringify({
            packageId: package_id,
            phoneNumberSelectionId: phone_number_selection_id,
            stripeSessionId: session.id,
            stripeSubscriptionId: session.subscription,
            stripeCustomerId: session.customer,
            user_id: user_id // Add user_id for webhook authentication
          })
        })

        if (!purchaseResponse.ok) {
          const errorText = await purchaseResponse.text()
          console.error('Failed to purchase phone number:', errorText)
          
          // Update status to failed
          await supabase
            .from('phone_number_selections')
            .update({
              status: 'purchase_failed',
              updated_at: new Date().toISOString()
            })
            .eq('id', phone_number_selection_id)
        } else {
          console.log('Phone number purchased successfully for session:', session.id)
          
          // Update status to purchased
          await supabase
            .from('phone_number_selections')
            .update({
              status: 'purchased',
              purchased_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('id', phone_number_selection_id)

          // Send confirmation emails
          try {
            console.log('üìß Preparing to send confirmation emails...')
            
            // Get customer email from Stripe
            let customerEmail = null
            let customerName = null
            
            if (session.customer_details?.email) {
              customerEmail = session.customer_details.email
            } else if (session.customer) {
              // Fetch customer from Stripe
              const customer = await stripe.customers.retrieve(
                typeof session.customer === 'string' ? session.customer : session.customer.id
              )
              if (customer && !customer.deleted) {
                customerEmail = customer.email
                customerName = customer.name || undefined
              }
            }
            
            // Get package info and format amount
            const packageName = `Telefoninumber ${phone_number}`
            const amount = session.amount_total ? `‚Ç¨${(session.amount_total / 100).toFixed(2)}` : 'N/A'
            
            if (customerEmail) {
              console.log('üìß Sending emails to:', customerEmail)
              
              const emailResult = await sendOrderEmails(customerEmail, {
                customerName,
                phoneNumber: phone_number,
                packageName,
                amount,
                sessionId: session.id,
                subscriptionId: typeof session.subscription === 'string' ? session.subscription : session.subscription?.id,
                customerId: typeof session.customer === 'string' ? session.customer : session.customer?.id
              })
              
              if (emailResult.success) {
                console.log('‚úÖ All confirmation emails sent successfully!')
              } else {
                console.log('‚ö†Ô∏è Some emails failed to send:', emailResult)
              }
            } else {
              console.log('‚ö†Ô∏è No customer email available, skipping email sending')
            }
          } catch (emailError) {
            console.error('‚ùå Error sending confirmation emails:', emailError)
            // Don't fail the webhook if email sending fails
          }
        }

      } catch (error) {
        console.error('Error processing completed payment:', error)
        
        // Update status to failed if we have the selection ID
        if (session.metadata?.phone_number_selection_id) {
          await supabase
            .from('phone_number_selections')
            .update({
              status: 'purchase_failed',
              updated_at: new Date().toISOString()
            })
            .eq('id', session.metadata.phone_number_selection_id)
        }
      }
      break

    case 'customer.subscription.updated':
      const updatedSubscription = event.data.object as Stripe.Subscription
      console.log('Subscription updated:', updatedSubscription.id, 'Status:', updatedSubscription.status)
      
      try {
        // Update rental status based on subscription status
        const { data: rental, error } = await supabase
          .from('rented_phone_numbers')
          .select('*')
          .eq('stripe_subscription_id', updatedSubscription.id)
          .single()

        if (rental && !error) {
          let rentalStatus = 'active'
          
          if (updatedSubscription.status === 'canceled' || 
              updatedSubscription.status === 'unpaid' ||
              updatedSubscription.status === 'past_due') {
            rentalStatus = 'suspended'
          }

          await supabase
            .from('rented_phone_numbers')
            .update({
              rental_status: rentalStatus,
              updated_at: new Date().toISOString()
            })
            .eq('id', rental.id)

          console.log('Rental status updated to:', rentalStatus, 'for subscription:', updatedSubscription.id)
        }
      } catch (error) {
        console.error('Error handling subscription update:', error)
      }
      break

    case 'customer.subscription.deleted':
      const deletedSubscription = event.data.object as Stripe.Subscription
      
      // Handle subscription cancellation
      console.log('Subscription cancelled:', deletedSubscription.id)
      
      try {
        // Find the rental associated with this subscription
        const { data: rental, error } = await supabase
          .from('rented_phone_numbers')
          .select('*')
          .eq('stripe_subscription_id', deletedSubscription.id)
          .single()

        if (rental && !error) {
          // Update rental status to cancelled
          await supabase
            .from('rented_phone_numbers')
            .update({
              rental_status: 'cancelled',
              rental_end_date: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('id', rental.id)

          console.log('Rental cancelled for subscription:', deletedSubscription.id)
        }
      } catch (error) {
        console.error('Error handling subscription cancellation:', error)
      }
      break

    case 'invoice.payment_failed':
      const invoice = event.data.object as Stripe.Invoice
      
      console.log('Payment failed for invoice:', invoice.id)
      
      // Handle failed payment - you might want to notify the user
      // or take action like suspending the service
      try {
        if (invoice.subscription) {
          const { data: rental } = await supabase
            .from('rented_phone_numbers')
            .select('*')
            .eq('stripe_subscription_id', invoice.subscription)
            .single()

          if (rental) {
            await supabase
              .from('rented_phone_numbers')
              .update({
                rental_status: 'suspended',
                updated_at: new Date().toISOString()
              })
              .eq('id', rental.id)

            console.log('Rental suspended due to payment failure for subscription:', invoice.subscription)
          }
        }
      } catch (error) {
        console.error('Error handling payment failure:', error)
      }
      break

    default:
      console.log(`Unhandled event type: ${event.type}`)
  }

  return new NextResponse(JSON.stringify({ received: true }), {
    status: 200,
  })
} 